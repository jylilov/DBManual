<html>
<head>
    <meta charset="utf-8">
</head>
<body>
    <h1>Получение итоговых значений </h1>
  	<p>
  		Как узнать количество моделей ПК, выпускаемых тем или иным поставщиком? Как определить среднее значение цены на компьютеры, имеющие одинаковые технические характеристики? На эти и многие другие вопросы, связанные с некоторой статистической информацией, можно получить ответы при помощи итоговых (агрегатных) функций. Стандартом предусмотрены следующие агрегатные функции:
  	</p>
  	<p>
  		<table border="1">
  			<thead>
  				<tr>
					<th> название</th>
					<th>  описание</th>
				</tr>
			</thead>
			<tbody>
				<tr>
				 <td>COUNT(*)     </td> <td>Возвращает количество строк источника записей</td></tr>
				<tr>
				 <td>COUNT     </td> <td>Возвращает количество значений в указанном столбце</td></tr>
				<tr>
				 <td>SUM     </td> <td>Возвращает сумму значений в указанном столбце</td></tr>
				<tr>
				 <td>AVG     </td> <td>Возвращает среднее значение в указанном столбце</td></tr>
				<tr>
				 <td>MIN     </td> <td>Возвращает минимальное значение в указанном столбце</td></tr>
				<tr>
				 <td>MAX     </td> <td>Возвращает максимальное значение в указанном столбце</td></tr>
			</tbody>
		</table>
  	</p>
  	<p>
  		Все эти функции возвращают единственное значение. При этом функции COUNT, MIN и MAX применимы к данным любого типа, в то время как SUM и AVG используются только для данных числового типа. Разница между функцией COUNT(*) и COUNT(имя столбца | выражение) состоит в том, что вторая (как и остальные агрегатные функции) при подсчете не учитывает NULL-значения.
	</p>
	<p>
		Найти минимальную и максимальную цену на персональные компьютеры:
  	</p>
  	<p>
  		<b>SELECT MIN(price) AS Min_price, MAX(price) AS Max_price FROM PC;</b>
  	</p>
  	<p>
  		Результатом будет единственная строка, содержащая агрегатные значения:
  	</p>
  	<p>
  		<table border="1">
  			<thead>
  				<tr>
					<th>Min_price</th>
					<th>Max_price</th>
				</tr>
			</thead>
			<tbody>
			<tr class="">
				 <td>350.0     </td> <td>980.0</td></tr>
			</tbody>
		</table>
  	</p>
  	<p></p>
  	<h1>Предложение GROUP BY</h1>
  	<p></p>
  	<p>
  		Предложение GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM). Если это предложение отсутствует, и используются агрегатные функции, то все столбцы с именами, упомянутыми в SELECT, должны быть включены в агрегатные функции, и эти функции будут применяться ко всему набору строк, которые удовлетворяют предикату запроса. В противном случае все столбцы списка SELECT, не вошедшие в агрегатные функции, должны быть указаны в предложении GROUP BY. В результате чего все выходные строки запроса разбиваются на группы, характеризуемые одинаковыми комбинациями значений в этих столбцах. После чего к каждой группе будут применены агрегатные функции. Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, то есть при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу.
  	</p>
  	<p>
  		Если при наличии предложения GROUP BY, в предложении SELECT отсутствуют агрегатные функции, то запрос просто вернет по одной строке из каждой группы. Эту возможность, наряду с ключевым словом DISTINCT, можно использовать для исключения дубликатов строк в результирующем наборе.
  	</p>
  	<p>
  		Рассмотрим простой пример:
  	</p>
  	<p>
  		<b>SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price FROM PC GROUP BY model;</b>
  	</p>
  	<p>
  		В этом запросе для каждой модели ПК определяется их количество и средняя стоимость. Все строки с одинаковыми значениями model (номер модели) образуют группу, и на выходе SELECT вычисляются количество значений и средняя цена для каждой группы. Результатом выполнения запроса будет следующая таблица
  	</p>
  	<p>
  		<table border="1">
  			<thead>
  				<tr>
					<th>model&nbsp;&nbsp;&nbsp;</th>
					<th>Qty_model&nbsp;&nbsp;&nbsp;</th>
					<th>Avg_price</th>
				</tr>
			</thead>
			<tbody>
				<tr class="">
				 <td>1121&nbsp;&nbsp;&nbsp; </td> <td>3&nbsp;&nbsp;&nbsp; </td> <td>850</td></tr>
				<tr class="alt">
				 <td>1232&nbsp;&nbsp;&nbsp; </td> <td>4&nbsp;&nbsp;&nbsp; </td> <td>425</td></tr>
				<tr class="">
				 <td>1233&nbsp;&nbsp;&nbsp; </td> <td>3&nbsp;&nbsp;&nbsp; </td> <td>843,333333333333</td></tr>
				<tr class="alt">
				 <td>1260&nbsp;&nbsp;&nbsp; </td> <td>1&nbsp;&nbsp;&nbsp; </td> <td>350</td></tr>
			</tbody>
		</table>
  	</p>
  	<p>
  		Если бы в SELECT присутствовал столбец с датой, то можно было бы вычислять эти показатели для каждой конкретной даты. Для этого нужно добавить дату в качестве группирующего столбца, и тогда агрегатные функции вычислялись бы для каждой комбинации значений {модель, дата}.
  	</p>
  	<p>
  		Существует несколько определенных правил выполнения агрегатных функций.
  	</p>
  	<p>
  		<ul>
  			<li>
  				<p>
  					Если в результате выполнения запроса не получено ни одной строки (или ни одной строки для данной группы), то исходные данные для вычисления любой из агрегатных функций отсутствуют. В этом случае результатом выполнения функций COUNT будет нуль, а результатом всех других функций — NULL.
				</p>
				<p>	
					Данное свойство может дать не всегда очевидный результат. Рассмотрим, например, такой запрос:
				</p>
				<p>
					<b>SELECT 1 a WHERE EXISTS(SELECT  MAX(price) FROM PC WHERE price<0)</b>
				</p>
				<p>
					Подзапрос в предикате EXISTS возвращает одну строку с NULL в качестве значения столбца. Поэтому, несмотря на то, что ПК с отрицательными ценами нет в базе данных, запрос в примере вернет 1.
				</p>
			</li>
			<li>
				<p>
					Аргумент агрегатной функции не может сам содержать агрегатные функции (функция от функции). То есть в простом запросе (без подзапросов) нельзя, скажем, получить максимум средних значений.
				</p>
			</li>
			<li>
				<p>
					Результат выполнения функции COUNT есть целое число (INTEGER). Другие агрегатные функции наследуют типы данных обрабатываемых значений.
				</p>
			</li>
			<li>
				<p>
					 Если при выполнении функции SUM будет получен результат, превышающий максимально возможное значение для используемого типа данных, возникает ошибка.
				</p>
			</li>
		</ul>
  	</p>
  	<p>
  		Итак, агрегатные функции, включенные в предложение SELECT запроса, не содержащего предложения GROUP BY, исполняются над всеми результирующими строками этого запроса. Если же запрос содержит предложение GROUP BY, каждый набор строк, который имеет одинаковые значения столбца или группы столбцов, заданных в предложении GROUP BY, составляют группу, и агрегатные функции выполняются для каждой группы отдельно.
  	</p>
  	<p></p>
  	<h1>Предложение HAVING</h1>
  	<p></p>
  	<p>
  		Если предложение WHERE определяет предикат для фильтрации строк, то предложение HAVING применяется после группировки для определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций. Это предложение необходимо для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, а из групп таких строк. Поэтому такая проверка не может содержаться в предложении WHERE.
  	</p>
  	<p>
  		<b>Получить количество ПК и среднюю цену для каждой модели, средняя цена которой менее $800</b>
  	</p>
  	<p>
  		<b>SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price FROM PC GROUP BY model HAVING AVG(price) < 800;</b>
  	</p>
  	<p>
  		В результате выполнения запроса получим:
  	</p>
  	<p>
  		<table border="1">
  			<thead>
  				<tr>
					<th>model</th>
					<th>Qty_model</th>
					<th>Avg_price</th>
				</tr>
			</thead>
			<tbody>
			<tr class="">
				 <td>1232    </td> <td>4    </td> <td>425</td></tr>
				<tr class="alt">
				 <td>1260    </td> <td>1    </td> <td>350</td></tr>
			</tbody>
		</table>
	</p>
  	<p>
  		Заметим, что в предложении HAVING нельзя использовать псевдоним (Avg_price), используемый для именования значений агрегатной функции в предложении SELECT. Дело в том, что предложение SELECT, формирующее выходной набор запроса, выполняется предпоследним перед предложением ORDER BY. Ниже приведен порядок обработки предложений в операторе SELECT:
  	</p>
  	<p>
  		<ul>
  			<li>FROM</li>
			<li>WHERE</li>
			<li>GROUP BY</li>
			<li>HAVING</li>
			<li>SELECT</li>
			<li>ORDER BY</li>
		</ul>
  	</p>
  	<p>
  		Этот порядок не соответствует синтаксическому порядку общего представления оператора SELECT, который ближе к естественному языку:
  	</p>
  	<p>
  		<b>SELECT [DISTINCT | ALL]{* | [<выражение для столбца> [[AS] <псевдоним>]] [,…]} FROM <имя таблицы> [[AS] <псевдоним>] [,…] [WHERE <предикат>] [[GROUP BY <список столбцов>] [HAVING <условие на агрегатные значения>] ] [ORDER BY <список столбцов>]</b>
  	</p>
  	<p>
  		Следует отметить, что предложение HAVING может использоваться и без предложения GROUP BY. При отсутствии предложения GROUP BY агрегатные функции применяются ко всему выходному набору строк запроса, т.е. в результате мы получим всего одну строку, если выходной набор не пуст.
  	</p>
  	<p>
  		Таким образом, если условие на агрегатные значения в предложение HAVING будет истинным, то эта строка будет выводиться, в противном случае мы не получим ни одной строки. Рассмотрим такой пример.
  	</p>
  	<p>
  		<b>Найти максимальную, минимальную и среднюю цену на персональные компьютеры.</b>
  	</p>
  	<p>
  		Решение этой задачи дает следующий запрос:
  	</p>
  	<p>
  		<b>SELECT MIN(price) AS min_price, MAX(price) AS max_price, AVG(price) avg_price FROM PC;</b>
  	</p>
  	<p>
  		результатам которого будет
  	</p>
  	<p>
  		<table border="1">
  			<thead>
  				<tr>
					<th>min_price</th>
					<th>max_price</th>
					<th>avg_price</th>
				</tr>
			</thead>
			<tbody>
			<tr class="">
				 <td>350.00 </td> <td>980.00    </td> <td>675.00</td></tr>
			</tbody>
		</table>
  	</p>	
  	<p></p>
  	<h1>Агрегатная функция от агрегатной функции</h1>
  	<p></p>
  	<p>
  		Давайте рассмотрим такую задачу:
	</p>
  	<p>
  		<b>Найти максимальное значение среди средних цен ПК, посчитанных для каждого производителя отдельно.</b>
	</p>
  	<p>
  		Посчитать средние значения стоимости по производителям труда не составляет:
	</p>
  	<p>
  		<b>SELECT AVG(price) avg_price FROM Product P JOIN PC ON P.model = PC.model GROUP BY maker;</b>
	</p>
  	<p>
  		Однако стандарт запрещает использовать подзапрос в качестве аргумента агрегатной функции, т.е. нельзя решить задачу следующим способом:
	</p>
  	<p>
  		<b>SELECT MAX(SELECT AVG(price) avg_price FROM Product P JOIN PC ON P.model = PC.model GROUP BY maker);</b>
	</p>
  	<p>
  		В подобных случаях используется подзапрос в предложении FROM:
	</p>
  	<p>
  		<b>SELECT MAX(avg_price) FROM (SELECT AVG(price) avg_price FROM Product P JOIN PC ON P.model = PC.model GROUP BY maker) X;</b>
	</p>
</body>
</html>